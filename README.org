
* BIMHAW: BashIng My Head Against a Wall

Cut the Gordian know of shell profiles on linux.

#+begin_quote
Whats the problem?
#+end_quote


Despite it being the most used interface as a linux user,
configuration of shells is unnecessarily obtuse and lacks many
important features.

#+begin_quote
I mean more specifically, and less ranty?
#+end_quote

1. Refactor shell startup scripts so that you can actually understand
  without thinking about it too much. 

Particularly the strange and subtle interactions between the system
shell (called "sh" or "posix shell" throughout despite whatever true
identity it has...).

2. Provide for different shell "profiles"

Having multiple profiles that are easily changed between is something
that I found a great need for in a system. There are multiple use
cases for this:

- Different profiles for different computers or environments.
- Always having a simple fall-back profile in case something breaks
  and you really shouldn't be working on debugging your dotfiles.
- Experimenting with new shell configurations without committing to
  it.
- Running demos, tutorials, or presentations where you want as little
  as possible to be able to go wrong.
- Activating your rice at the cafe, but then returning to your uncool
  comfort setup in the comfort of your home.

3. Proper (re)factoring of shell configuration scripts

In addition to being very aesthetically messy and difficult to debug
dumping all configuration into a single ~.bash_profile~ doesn't really
work well for multiple profiles. Multiple profiles would require a lot
of duplicated code/configuration since many of them will share the
same features. So we provide a rough module system. Where modules are
just scripts for different roles like environment, aliases, and
autocompletion placed in certain directories. The modules for each
profile are specified by name in configuration file.

#+begin_quote
Sounds complicated, whats the solution?
#+end_quote

** How it works

To refactor the shell startup we provide a single set of replacement
contentless startup files located at ~$HOME/.bimhaw/shell_dotfiles~.
These in turn source another set of startup scripts with clean
sensible names that are expected to be at ~$HOME/.bimhaw/active~.  These
clean sensible ones are provided as templates (using jinja2) so you
can easily generate many of them.  These scripts are also relatively
contentless and will only contain listings of which modules they are
to use (which come from the configuration file).

The template generation and configuration reader are implemented as a
python library and CLI tool.

#+begin_src bash
bimhaw profile.gen --name 'work'
#+end_src

This command will read ~.bimhaw/config.py~ (yes it uses ~exec~ so make
sure you only have trusted code which shouldn't be a problem since it
is just setting some strings).  It picks out the values for the 'work'
profile and fills them into the template script files. The generated
scripts as a collection are referred to as a single 'profile'. Once
these are generated they are saved in ~.bimhaw/profiles/work~.

However the ~shell_dotfiles~ expect profiles to be at the
~.binhaw/active~ location, which we make a symlink to one of the
profiles.  Running this command will both generate the profile and
symlink ~.bimhaw/active~ to ~.bimhaw/profiles/work~:

#+begin_src bash
bimhaw profile.load --name 'work'
#+end_src

However, the profile won't be active yet for your bash or posix shell
because it expects the following configuration files:

- ~$HOME/.profile~
- ~$HOME/.bash_profile~
- ~$HOME/.bash_logout~
- ~$HOME/.bashrc~

To link the shells in the ~.bimhaw~ directory to those expected
targets backup your existing shell scripts at the above locations and
run:

#+begin_src bash
bimhaw link-shells
#+end_src

Those startup files should now be symlinks to
~$HOME/.bimhaw/active/profile~ etc.

We've solved this terrible legacy cruft with a couple levels of
indirection and so is more complicated (i.e. not KISS some ugliness is
necessary to get shit done I'm afraid). Here is the high level linking
structure (roughly) to help you understand.:

#+begin_example
shell startup --> ~.profile~ --> ~.bimhaw/shell_dotfiles/profile~ --> ~.bimhaw/active~ --> ~.bimhaw/profiles/work~ --> ~.bimhaw/lib/shell~
#+end_example


** Configuring your shells: modules

There are a few different roles of modules:

- envs :: define environmental variables, call other executables,
          etc. most of the "code" part of configuration
- funcs :: functions in the bash or sh sense, whatever that means
- aliases :: things you create with the shell builtin ~alias~
- logouts :: scripts to run when you logout
- prompts :: choice of a prompt
- autocompletion :: autocompletion scripts (bash only)

The modules for posix shell are in ~.bimhaw/lib/shell/sh~ and for bash
they are in ~.bimhaw/lib/shell/bash~.

It's important to note that in ~bimhaw~ all modules in a profile that
are loaded for 'sh' will also be loaded for 'bash'. The modules
specified for bash will be /bash only/. This allows for "pure" and
"portable" posix sh scripts (we all know you ~sh~ scripts are only of
the highest quality and POSIX compliant...) and also configurations
with bashisms.

* Getting Started

Install it from the git repo directly:

#+begin_src bash
pip install git+https://github.com/salotz/bimhaw.git
#+end_src

Once you have it installed you will need to create a configuration
directory at ~$HOME/.bimhaw~.

You can and should do this with the initialization command:

#+begin_src bash
python -m bimhaw.init
#+end_src

Now you should have a ~$HOME/.bimhaw~ directory with some folders.

This will fail if the directory already exists.

Now that we have the configuration directory setup we want to set up a
profile to use.

To create profiles we run the main command line application:

#+begin_src bash
bimhaw profile.gen --name 'bimhaw'
#+end_src

If you run it like this you will create the default and only built-in
profile that bimhaw has called 'bimhaw'. If you want to create your
own profiles you will need to edit the ~~/.bimhaw/config.py~ file
which is discussed in [[*Creating new profiles][Creating new profiles]].

Now we need to activate this profile which is simply done by running:

#+begin_src bash
bimhaw profile.load --name 'bimhaw'
#+end_src

This simply makes the symbolic link ~.bimhaw/active~ point to the
specified profile directory.

And technically it will also rerun the ~profile.gen~ subcommand again,
so in the future you only have to run the one command.

#+begin_src bash
bimhaw profile --name bimhaw
#+end_src

To actually get this profile loaded upon startup of your shell we need
to link the actual shell startup files to the ones where the shell
programs expect them to be.

Please go and back up your current dotfiles, these dotfiles will need
to be turned into symbolic links:

- ~$HOME/.profile~
- ~$HOME/.bash_profile~
- ~$HOME/.bash_logout~
- ~$HOME/.bashrc~

Once they are backed up you can run:

#+begin_src bash
bimhaw link-shells
#+end_src

If you didn't delete or move the listed startup files then either do
so or run with the 'force' flag:

#+begin_src bash
bimhaw link-shells --force
#+end_src


** Creating new profiles

Lets say we want to create a common use profile.

We would edit the ~config.py~ file so that it looked something like
this:

#+begin_src python
  PROFILES = [
    'bimhaw',
    'common',
  ]

  # POSIX shell (whatever that is)
  SH_LOGIN_ENVS = {

    'bimhaw' : [
    ],

    'common' : [
    ],
  }



  SH_NONLOGIN_ENVS = {

    'bimhaw' : [
    ],

    'common' : [
    ],
  }


  # scripts to run on logout
  SH_LOGOUTS = {

    'bimhaw' : [
    ],

    'common' : [
    ],

  }


  # salotz.sh_aliases
  SH_ALIASES = {

    'bimhaw' : [
    ],

    'common' : [
    ],

  }


  # salotz.sh_funcs
  SH_FUNCS = {

    'bimhaw' : [
    ],

    'common' : [
    ],

  }


  SH_PROMPT = {
    'bimhaw' : 'default',
    'common' : 'default',
  }

  BASH_PROMPT = {
    'bimhaw' : 'default',
    'common' : 'default',
  }

  BASH_LOGIN_SH_ENVS = {

    'bimhaw' : [
    ],

    'common' : [
    ],
  }

  BASH_LOGIN_BASH_ENVS = {

    'bimhaw' : [
    ],

    'common' : [
    ],
  }


  BASH_NONLOGIN_ENVS = {

    'bimhaw' : [
    ],

    'common' : [
    ],
  }

  BASH_INTERACTIVE_ENVS = {

    'bimhaw' : [
    ],

    'common' : [
    ],
  }

  BASH_ALIASES = {

    'bimhaw' : [
    ],

    'common' : [
    ],
  }

  BASH_FUNCS = {

    'bimhaw' : [
    ],

    'common' : [
    ],
  }

  BASH_AUTOCOMPLETIONS = {
    'bimhaw' : [
    ],

    'common' : [
    ],
  }
#+end_src

Apologies for the verboseness, but I didn't want to commit to any
configuration system as of now.

Since there are no config files to differentiate the 'common' profile
from the 'bimhaw' it will be the same. You can add new content for it
by adding files to the folders in the ~lib~ directory.

To create this profile run:

#+begin_src bash
bimhaw profile.gen --name common
#+end_src



* Diatribe

** Shells

A system is interacted with by a shell and so the shells must be the
first thing to be configured.

Unfortunately, on unix-like systems, such as linux, the configuration
of shells is extremely and unnecessarily complex for historical
reasons.


*** Introduction to the complexity of unix shells

The first thing we must consider is the features implementated by the
shell (or shells) that will be on the systems you will be configuring.


Furthermore, the capabilities, features, and syntax of shells is
highly divergent. This would be okay if there were value-added shells
that could be used on specific systems and setups, were there a
standard shell that could be used across different systems.

This is why the POSIX shell standard was developed, which is only a
*specification* and not an implementation.

This specification furthermore is dated and idiosyncratic, and no
shell implements the specified features on a 1:1 basis.

The most used shells, bash and zsh, implement many more features than
the POSIX shell and the use of scripts written with them will vary
from system to system.

A shell script written adhering to the POSIX standards should run in
all shells, but it requires that the author understand that all
features of the shell they are using should not be used.

Of course this is not entirely true in practice and there are
discrepencies between the shells.

So the best advice for writing shell scripts that are meant to be
portable is to keep them very simple.

If you need more advanced control flow, consider using a shell or
programming language (that is a more sane language than a bash-type
language) which is easily available on all systems you wish to
configure (such as python).

To make matters worse (at least) bash has the ability to run in a
separate mode that alters its behavior to adhere more to a pure POSIX
shell.

This can happen if an explicit flag is raised during invocation, or if
the ~/bin/sh~ file is a symlink to the bash binary (I know a rather
strange and special case behavior). Details on the change in behavior
can be found here:
https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html

The shell executable located at ~/bin/sh~ is for all POSIX systems
assumed to be a POSIX compliant shell and should be declared as the
runner for all scripts intended to be executed by a POSIX shell. That
is scripts that are intended to be portable across POSIX operating
systems.

Different distros use different shells for ~/bin/sh~ but the most
popular seem to be ~dash~ (Debian Almquist Shell) and ~bash~.

Bash is used because it is the most widely used shell, however, it
will be run in compatibility mode as described above and will not be
the shell you know, and perhaps love.

The ~dash~ shell is used because it is much faster than other shells
and is an attempt to be as compliant as possible to the POSIX
standard. I will assume for my purposes that ~dash~ /is/ the reference
implementation of the POSIX shell. So any script that is written
should be tested against the ~dash~ shell before being considered
portable.

*** Configuring shell startups

Configuring the runtime properties and environment of a shell is also
a convoluted mess, in part due to a complex set of different modes
that shells can be started in and a mistrust on the adherence to the
behavior that is documented in the manual.

The documented behavior is shown in this diagram:

[[file:docs/shell-startup.png]]

Basically a shell can be started with 3 options:

- login or nonlogin
- interactive or batch
- local or remote

The files that get read and executed as part of the configuration
changes with which modes are activated.

Here is a table showing which configuration scripts are executed and
in what order for different options. The labelled columns are the
different states that trigger sourcing of files.

Files are sourced in alphabetic order. Numbers indicate choices for
sourcing at a given stage, and the lowest number will be searched for
first. The first one encountered will be sourced and the rest will be
skipped.

|------------------+-------------+-------------+--------+-----------+--------|
|                  | Interactive | Interactive | Batch  | Batch     | Remote |
|------------------+-------------+-------------+--------+-----------+--------|
|                  | login       | non-login   | login  | non-login |        |
|------------------+-------------+-------------+--------+-----------+--------|
| /etc/profile     | A           |             |        | A         |        |
|------------------+-------------+-------------+--------+-----------+--------|
| /etc/bash.bashrc |             | A           |        |           |        |
|------------------+-------------+-------------+--------+-----------+--------|
| ~/.bashrc        |             | B           |        |           | A      |
|------------------+-------------+-------------+--------+-----------+--------|
| ~/.bash_profile  | B1          |             |        | B1        |        |
|------------------+-------------+-------------+--------+-----------+--------|
| ~/.bash_login    | B2          |             |        | B2        |        |
|------------------+-------------+-------------+--------+-----------+--------|
| ~/.profile       | B3          |             |        | B3        |        |
|------------------+-------------+-------------+--------+-----------+--------|
| BASH_ENV         |             |             | A      | C         |        |
|------------------+-------------+-------------+--------+-----------+--------|
|                  | Logout      |             | Logout |           |        |
|------------------+-------------+-------------+--------+-----------+--------|
| ~/.bash_logout   | A           |             | A      |           |        |
|------------------+-------------+-------------+--------+-----------+--------|


Here is the table for POSIX shells:

|------------+-------------+-------------+-------+-----------|
|            | Interactive | Interactive | Batch | Batch     |
|------------+-------------+-------------+-------+-----------|
|            | login       | non-login   | login | non-login |
|------------+-------------+-------------+-------+-----------|
| ~/.profile | A           |             | A     |           |
|------------+-------------+-------------+-------+-----------|
| ENV        | B           | A           |       |           |
|------------+-------------+-------------+-------+-----------|


Because of the complexity of this process and the fact that we don't
want to duplicate the coding of environments which will be the same
between shells, we code these common configurations in POSIX shell.

To map onto these logical categories of different shell stages we
write shell scripts for each shell in the 'shells' directory.

These scripts include:

- env
- interactive
- login
- logout

The 'env' script is run for all cases including batch and the others
are to be run for their respective states.

Through clever sourcing of these dependencies between these files
among different shells we can separate configurations common to all
POSIX shells (in the ~posix~ dir) and for each specific shell, each
having a dir with it's namesake.

These initialization files are intended to encapsulate the logic
necessary for this trick of dependencies, and most of the actual
content of the configurations is found, logically, in with the rest of
the configurations under the name of the shell, which may have
configurations added as if it were any other program.

To deploy these shell scripts to a system however we provide the
'dotfiles' indicated in the tables above, in the ~shells/dotfiles~
folder. The mapping of these file names to their locations in a system
filesystem can be found in ~shells.config.toml~. 

The script ~bin/link_shells.sh~ will create symlinks in the system to
the appropriate shell configuration "dotfiles" for the current user,
assuming the dotsalotz repository is at ~$HOME/.salotz.d~.



*** Configuring shell environments

To configure the shells environment (and thus behavior) find the
relevant directory in the ~configs~ folder and edit the files there.

The ~interactive.sh~ file will be run in an interactive shell and
should be used to set:

- aliases
- functions
- prompt appearance
- autocompletion
- other interactive shell specific features

The more important file is the ~env.sh~ file which is currently only
in the ~sh~ config as there are no bash specific environmental
features and this should be favored over the bash config folder unless
you know it to be necessary.

Some configuration files don't contain any configuration themselves,
but simply source configurations from their associated collection of
files of the same basename. These include:

- sh
  - env.sh
  - funcs.sh
- bash
  - funcs.bash
  - autocompletion.bash

To configure which files are sourced change the names in the `lib`
array in those scripts.

This may improve in the future.

